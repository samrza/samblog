<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BowtiedFox - Surviving Ai Notes</title>
    <link rel="stylesheet" href="../css/style.css" />
    <link rel="icon" type="image/x-icon" href="../images/favicon.png" />
  </head>
  <body>
    <div class="container">
      <!-- Navbar -->
      <header class="navbar">
        <a href="../index.html" class="logo">
          <img src="../images/dp.jpg" alt="SR Logo" class="logo-img" />
        </a>
        <nav class="nav-links">
          <a href="../pages/about.html">About</a>
          <a href="../pages/project.html">Projects</a>
          <a href="../pages/writing.html">Writings</a>
          <a href="../pages/reading.html">Reading</a>
        </nav>
      </header>

      <!-- About Section -->
      <section class="about">
        <h2 class="pages-title">BowtiedFox - Surviving Ai Notes</h2>
        <mark>intro</mark>
        <p>
          The traditional wealth path — get a high-paying job, start a business,
          invest profits — still works, but AI has raised the bar for everyone.
          Easy tasks are being automated, junior roles are shrinking, and
          competition is fierce because AI tutoring lets anyone learn faster.
        </p>
        <p>
          To win, you can’t just follow the rules; wealth comes from ownership,
          arbitrage, and moving quickly when big changes (like AI) happen. Many
          “AI tools” are just ChatGPT with a nicer interface, and most people
          don’t know how it works — that’s your opportunity.
        </p>
        <p>
          Two best career paths now: Sales: Still valuable for building trust in
          big purchases, now boosted by AI tools. Programming: Costs to build
          software are lower than ever, and software scales infinitely. Pick the
          one you enjoy, build skills, and use them to eventually own your own
          product or company. Move fast before the market catches up.
        </p>
        <mark>Programming Jobs</mark>
        <p>
          AI is automating low-skill coding work, but strong programmers are
          still needed to review AI’s output, prevent bugs, handle complex
          tradeoffs, and ensure companies avoid legal issues. Specializing in a
          niche and building high-level skills is key
        </p>
        <p>
          FAANG jobs are worth aiming for because they offer huge salaries,
          flexible career options, prestige, world-class learning environments,
          and elite networks that open doors for future roles or funding.
          Competition is tough, but the rewards are life-changing.
        </p>
        <p>
          Big tech interviews are highly standardized and focus almost entirely
          on algorithm problem-solving, not degrees or flashy projects. Startups
          care more about practical skills and personal fit, while non-tech
          companies have easier interviews but lower pay.
        </p>
        <p>
          The right way to prepare is by mastering algorithm patterns so you can
          instantly recognize the best approach in different scenarios, rather
          than memorizing hundreds of questions. This makes you adaptable to any
          twist.
        </p>
        <p>
          These interviews also assess deeper traits: structured thinking, clear
          communication, collaboration, handling complexity, and staying calm
          under pressure. Building these abilities not only helps you get hired
          but also future-proofs your career from AI displacement.
        </p>
        <div style="text-align: center">
          <img
            src="/images/bowtiedfox-article.png"
            alt="Bowtied Fox Article"
            style="max-width: 400px; width: 100%; height: auto"
          />
        </div>

        <p>
          BowtiedFox advice - At any moment, ask yourself: “What’s the best
          thing I could be doing right now?” If you don’t know, define the
          problem clearly, then either research it or ask someone more
          knowledgeable. It’s basically about clarity, discipline, and delayed
          gratification — applied not just in work but in everyday life.
        </p>
        <mark>Prerequisites for Algorithms</mark>
        <p>
          You need math basics and programming fundamentals before learning
          algorithms. Suggested free courses (MIT OpenCourseWare):
        </p>
        <ul>
          <li>Introduction to Computer Science and Programming (6.0001)</li>
          <li>Mathematics for Computer Science (6.042J)</li>
          <li>Introduction to Algorithms (6.006)</li>
        </ul>
        <p>
          Avoid “analysis paralysis” — don’t obsess over which book is best
          (CLRS, Skiena, etc.). Pick one, learn the basics, then practice. Core
          requirement: be able to write basic algorithms like binary search,
          DFS, BFS from scratch.
        </p>

        <h3>Practicing Algorithms</h3>
        <p>
          Best platform: LeetCode (problems sorted by topic, difficulty, and
          company). Problems get easier with practice — nobody is good at
          LeetCode from day one. Aim for:
        </p>
        <ul>
          <li>Easy: 10–15 min</li>
          <li>Medium: 20–30 min</li>
          <li>Hard: ~45 min (often a medium with extra restrictions)</li>
        </ul>
        <p>
          Spend at least 1 hour before looking at solutions — build resilience.
        </p>
        <p>
          Choosing Problems - Prefer questions with higher acceptance rates
          (usually clearer wording). Do company-specific tagged problems before
          interviews.
        </p>
        <h3>Problem-Solving Process</h3>
        <ul>
          <li>Understand problem: inputs, outputs, constraints, edge cases.</li>
          <li>Recognize patterns: match to known problems.</li>
          <li>Plan solution before coding.</li>
          <li>Write code.</li>
          <li>Check correctness.</li>
          <li>Optimize if possible.</li>
        </ul>
        <p>Priority order: Correct → Efficient → Clean.</p>

        <p>Correctness - It’s easier to prove a solution wrong than right.</p>
        <p>Use decision coverage: test every branch of logic.</p>

        <p>Test for:</p>
        <ul>
          <li>Boundary cases (min/max, empty data, etc.)</li>
          <li>Test for: Uniform inputs (all same)</li>
          <li>Special values (negative, zero, even/odd, prime)</li>
          <li>Loop edge cases (zero/one/many iterations)</li>
          <li>Tiebreakers (equal values in sorting)</li>
        </ul>
        <p>
          Even if you don’t write all test cases in code, mention them to the
          interviewer.
        </p>
        <h3>Efficiency</h3>
        <p>
            Big-O basics - Describes how runtime grows with input size (worst case focus).
        </p>
        <p>
            Common complexities:
        </p>
        <ul>
            <li>O(1) Constant</li>
            <li>O(log N) Logarithmic</li>
            <li>O(N) Linear</li>
            <li>O(N log N) Log-linear</li>
            <li>O(N²) Quadratic</li>
            <li>O(N³) Cubic</li>
            <li>O(2ᴺ) Exponential</li>
        </ul>
        <p>
            Optimization rules :
        </p>
        <ul>
            <li>Improve naive solution by at least one level (e.g., O(N³) → O(N²)).</li>
            <li>Identify bottlenecks (highest complexity step) first.</li>
            <li>Remove unnecessary work (reduce loops if possible).</li>
            <li>Avoid duplicate work (cache results / memoization).</li>
        </ul>
        <h3>
            Clean Code
        </h3>
        <ul>
            <li>Use descriptive variable names.</li>
            <li>Apply DRY (Don’t Repeat Yourself) — use loops/functions for repeated logic.</li>
            <li>Use explaining variables to make code self-explanatory.</li>
            <li>Rewrite conditionals to read like natural language, avoid confusing negations.</li>
            <li>Remember: code is read more than it’s written — prioritize clarity for humans.</li>
        </ul>
        <p>Use descriptive variable names.</p>
        <p>Apply DRY — use loops/functions for repeated logic.</p>
      </section>

      <!-- Footer -->
      <footer>
        <div class="footer-links">
          <a href="https://github.com/samrza/" target="_blank">GitHub</a>
          <a href="https://x.com/samrza_" target="_blank">X</a>
          <a href="pages/micro-blog.html">Microblog</a>
          <!-- <a href="#" target="_blank">RSS</a> -->
          <a href="/pages/now.html" target="_blank">Now</a>
          <a href="mailto:sameer4uofficial@gmail.com" target="_blank"
            >Contact</a
          >
          <a href="https://www.instagram.com/samrza_/" target="_blank"
            >Instagram</a
          >
        </div>
        <p>© 2022 – 2025 Sameer Raza</p>
      </footer>
    </div>
  </body>
</html>
